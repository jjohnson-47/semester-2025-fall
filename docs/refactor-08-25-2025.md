Here's a comprehensive refactor plan that transforms your project into a robust, long-term architecture while preserving your existing work:

## **Phase 1: Data Foundation (Week 1-2)**

### 1.1 Add Stable Identity Layer

```python
# scripts/migrations/add_stable_ids.py
"""
Add stable IDs to all existing JSON files.
Format: {YEAR}{TERM}-{COURSE}-{TYPE}-{SEQUENCE}
Example: 2025FA-M221-HW-01, 2025FA-M221-EXAM-M1
"""

def migrate_schedule_json(course_id: str):
    path = f"content/courses/{course_id}/schedule.json"
    data = json.load(open(path))
    
    for week_num, week in enumerate(data.get('weeks', []), 1):
        for item in week.get('assignments', []):
            if 'id' not in item:
                item['id'] = generate_stable_id(course_id, 'HW', week_num)
        
        for item in week.get('assessments', []):
            if 'id' not in item:
                exam_type = 'EXAM' if 'exam' in item['title'].lower() else 'QUIZ'
                item['id'] = generate_stable_id(course_id, exam_type, week_num)
```

### 1.2 Schema Evolution System

```python
# scripts/schema/versions/
v1_0_0/
  course_meta.schema.json
  schedule.schema.json
  # ... etc

v1_1_0/  # Adds required 'id' fields
  course_meta.schema.json
  schedule.schema.json

# scripts/schema/migrator.py
class SchemaMigrator:
    def migrate(self, data: dict, from_version: str, to_version: str):
        """Apply migrations in sequence"""
        migrations = self.get_migration_chain(from_version, to_version)
        for migration in migrations:
            data = migration.apply(data)
            data['schemaVersion'] = migration.target_version
        return data
```

### 1.3 Standardize File Headers

Add to every JSON file:
```json
{
  "_meta": {
    "schemaVersion": "1.1.0",
    "term": "2025-fall",
    "timezone": "America/Anchorage",
    "lastModified": "2025-08-25T10:00:00-08:00",
    "generator": "manual|script|dashboard"
  },
  // ... existing content
}
```

## **Phase 2: Rules Engine (Week 2-3)**

### 2.1 Core Rules Service

```python
# scripts/rules/__init__.py
from typing import Protocol

class RuleEngine(Protocol):
    """All business logic lives here"""
    def apply(self, context: dict) -> dict: ...

# scripts/rules/engine.py
class CourseRulesEngine:
    def __init__(self):
        self.rules = [
            DateRules(),        # No weekends, holiday shifts
            PolicyRules(),      # Grading totals, late penalties
            ComplianceRules(),  # RSI requirements, accessibility
            DependencyRules(),  # Prerequisites, sequencing
        ]
    
    def normalize_course(self, course_id: str) -> NormalizedCourse:
        # Load raw data
        raw = self.load_raw_data(course_id)
        
        # Apply each rule family
        context = NormalizedCourse(course_id=course_id, raw=raw)
        for rule in self.rules:
            context = rule.apply(context)
            context.add_provenance(rule.name, rule.version)
        
        return context
```

### 2.2 Date Authority

```python
# scripts/rules/dates.py
class DateRules:
    """Centralized date logic - NOTHING else does date math"""
    
    def __init__(self, calendar_service):
        self.calendar = calendar_service
        self.tz = pytz.timezone("America/Anchorage")
    
    def apply(self, context: NormalizedCourse) -> NormalizedCourse:
        for assignment in context.assignments:
            original_due = assignment.due
            
            # Apply rules in order
            adjusted = self.ensure_weekday(original_due)
            adjusted = self.avoid_holidays(adjusted)
            adjusted = self.apply_course_preferences(adjusted, context)
            
            assignment.due = adjusted
            assignment.due_original = original_due
            assignment.due_sources = [
                "schedule.json#week3",
                "rules:no_weekends@1.0.0",
                "rules:holiday_shift@1.0.0"
            ]
        
        return context
```

### 2.3 Provenance Tracking

```python
# scripts/rules/models.py
@dataclass
class NormalizedField:
    value: Any
    original_value: Any
    sources: List[str]  # What contributed to this value
    rules_applied: List[str]  # Which rules modified it
    confidence: float  # 1.0 = explicit, 0.5 = heuristic
    
@dataclass
class NormalizedCourse:
    course_id: str
    facts: dict  # Immutable input data
    computed: dict  # Derived by rules
    metadata: dict  # Provenance, versions, timestamps
```

## **Phase 3: Service Layer (Week 3-4)**

### 3.1 Unified Course Service

```python
# scripts/services/course_service.py
class CourseService:
    """Single entry point for all course data access"""
    
    def __init__(self, course_id: str):
        self.course_id = course_id
        self.rules_engine = CourseRulesEngine()
        self._normalized = None
        self._cache_key = None
    
    @property
    def normalized(self) -> NormalizedCourse:
        """Lazy load and cache normalized data"""
        cache_key = self._compute_cache_key()
        if cache_key != self._cache_key:
            self._normalized = self.rules_engine.normalize_course(self.course_id)
            self._cache_key = cache_key
        return self._normalized
    
    def get_template_context(self, template: str) -> dict:
        """Project normalized data for template consumption"""
        context = self.normalized
        
        if template == "syllabus":
            return {
                'course': context.facts['meta'],
                'policies': context.computed['policies'],
                'schedule_summary': context.computed['schedule_summary'],
                'instructor': context.facts['instructor'],
                # Only presentation data, no logic
            }
        # ... other templates
    
    def get_intelligence_view(self) -> dict:
        """Project normalized data for task engine"""
        context = self.normalized
        
        return {
            'critical_dates': self._extract_critical_dates(context),
            'dependencies': self._build_dependency_graph(context),
            'compliance_status': self._check_compliance(context),
            'generation_state': self._get_generation_state()
        }
```

### 3.2 Validation Gateway

```python
# scripts/services/validation.py
class ValidationGateway:
    def __init__(self):
        self.validators = {
            'schema': SchemaValidator(),
            'business': BusinessRuleValidator(),
            'integrity': IntegrityValidator()
        }
    
    def validate_for_build(self, course_id: str) -> ValidationResult:
        """Can we generate documents?"""
        results = []
        
        # Schema compliance
        results.append(self.validators['schema'].validate(course_id))
        
        # Business rules (no weekend dues, etc)
        normalized = CourseService(course_id).normalized
        results.append(self.validators['business'].validate(normalized))
        
        return ValidationResult.merge(results)
    
    def validate_for_intelligence(self, course_id: str) -> ValidationResult:
        """Can the task engine understand this?"""
        # Requires stable IDs, parseable dates, complete dependencies
        pass
```

### 3.3 Change Detection Service

```python
# scripts/services/changes.py
class ChangeDetector:
    def __init__(self):
        self.manifest_path = "build/manifest.json"
        self.previous_manifests = "build/history/"
    
    def detect_changes(self, course_id: str) -> List[Change]:
        current = self._compute_fingerprints(course_id)
        previous = self._load_previous_fingerprints(course_id)
        
        changes = []
        for path, current_hash in current.items():
            if path not in previous:
                changes.append(Change('added', path))
            elif previous[path] != current_hash:
                changes.append(Change('modified', path, 
                    impact=self._compute_impact(path)))
        
        return changes
    
    def _compute_impact(self, path: str) -> List[str]:
        """What needs rebuilding when this file changes?"""
        impacts = {
            'schedule.json': ['schedules', 'syllabi', 'tasks', 'blackboard'],
            'due_dates.json': ['schedules', 'tasks'],
            'policies.json': ['syllabi', 'tasks'],
        }
        return impacts.get(path.split('/')[-1], ['all'])
```

## **Phase 4: Data Pipeline (Week 4-5)**

### 4.1 Directory Restructure

```
content/
  courses/
    MATH221/
      v1/  # Current data
        *.json
      archive/  # Historical versions
        2025-08-01/
        
build/
  normalized/  # Rules engine output
    MATH221.normalized.json
    MATH221.normalized.json.manifest
    
  intelligence/  # Task engine views
    MATH221.intelligence.json
    MATH221.dependencies.json
    
  templates/  # Template contexts
    MATH221.syllabus.context.json
    MATH221.schedule.context.json
    
  artifacts/  # Generated documents
    syllabi/
    schedules/
    
  reports/  # Build reports
    MATH221.report.md
    changes.jsonl
```

### 4.2 Unified Build Pipeline

```python
# scripts/build_pipeline.py
class BuildPipeline:
    def __init__(self, courses: List[str]):
        self.courses = courses
        self.stages = [
            ('validate', self.validate_stage),
            ('normalize', self.normalize_stage),
            ('project', self.project_stage),
            ('generate', self.generate_stage),
            ('package', self.package_stage),
            ('report', self.report_stage)
        ]
    
    def run(self, force=False):
        for course_id in self.courses:
            changes = ChangeDetector().detect_changes(course_id)
            
            if not changes and not force:
                logger.info(f"Skipping {course_id}: no changes")
                continue
            
            for stage_name, stage_func in self.stages:
                try:
                    stage_func(course_id, changes)
                except StageError as e:
                    self.handle_error(course_id, stage_name, e)
                    break
```

### 4.3 Template Migration

```python
# scripts/migrate_templates.py
"""
Templates should ONLY format data, never compute it
"""

# OLD template code:
{% if assignment.due.weekday() in [5,6] %}
  {% set assignment.due = assignment.due + timedelta(days=...) %}
{% endif %}

# NEW template code:
{{ assignment.due_formatted }}  {# Pre-computed by rules engine #}
{{ assignment.due_warning }}    {# Pre-computed warning if needed #}
```

## **Phase 5: Dashboard Integration (Week 5-6)**

### 5.1 Task Engine Refactor

```python
# dashboard/services/task_intelligence.py
class TaskIntelligence:
    def __init__(self):
        self.rules = self._load_task_rules()
    
    def generate_tasks(self, course_id: str) -> List[Task]:
        # Read from intelligence projection, not raw JSON
        intel = json.load(open(f"build/intelligence/{course_id}.intelligence.json"))
        
        tasks = []
        
        # Check critical dates
        for date in intel['critical_dates']:
            if date['needs_review']:
                tasks.append(Task(
                    id=f"review-{date['id']}",
                    title=f"Review: {date['description']}",
                    source=date['sources'],
                    priority=date['priority']
                ))
        
        # Check compliance
        for rule in intel['compliance_status']:
            if not rule['compliant']:
                tasks.append(self._create_compliance_task(rule))
        
        return tasks
```

### 5.2 Dashboard State Management

```python
# dashboard/state/manager.py
class StateManager:
    def __init__(self):
        self.state_dir = Path("dashboard/state")
        self.history_dir = self.state_dir / "history"
        
    def snapshot(self, label: str = None):
        """Create immutable snapshot of current state"""
        timestamp = datetime.now().isoformat()
        snapshot_dir = self.history_dir / timestamp
        
        # Copy all current state files
        for file in self.state_dir.glob("*.json"):
            shutil.copy2(file, snapshot_dir / file.name)
        
        # Add metadata
        metadata = {
            'timestamp': timestamp,
            'label': label,
            'courses': self._get_course_states(),
            'manifest': self._compute_checksums()
        }
        
        (snapshot_dir / "metadata.json").write_text(json.dumps(metadata))
```

## **Phase 6: Quality Assurance (Week 6-7)**

### 6.1 Golden Testing

```python
# tests/golden/test_golden_outputs.py
class TestGoldenOutputs:
    def test_math221_normalization(self, golden_fixture):
        service = CourseService('MATH221')
        normalized = service.normalized
        
        golden_path = Path("tests/golden/MATH221.normalized.golden.json")
        
        if UPDATE_GOLDEN:
            golden_path.write_text(normalized.to_json(indent=2))
        else:
            golden = json.loads(golden_path.read_text())
            assert normalized.to_dict() == golden
            
    def test_math221_syllabus_context(self, golden_fixture):
        service = CourseService('MATH221')
        context = service.get_template_context('syllabus')
        
        # Test specific invariants
        assert context['policies']['grading_total'] == 100.0
        assert not any(is_weekend(a['due']) for a in context['assignments'])
        
        # Compare to golden
        golden_path = Path("tests/golden/MATH221.syllabus.context.golden.json")
        # ...
```

### 6.2 Contract Testing

```yaml
# tests/contracts/dates.yaml
contracts:
  - name: no_weekend_dues
    description: No assignments due on weekends
    query: |
      normalized.assignments[*].due | 
      [?dayOfWeek(@) in ['Saturday', 'Sunday']]
    expect: []
    
  - name: exam_spacing
    description: Exams at least 7 days apart
    query: |
      normalized.assessments[?type=='exam'] |
      sort_by(@, &due) | 
      [?daysBetween(@.due, @[-1].due) < 7]
    expect: []
```

### 6.3 Build Reports

```python
# scripts/reporting/build_reporter.py
class BuildReporter:
    def generate_report(self, course_id: str) -> str:
        """Generate comprehensive build report"""
        
        report = f"""
# Build Report: {course_id}
Generated: {datetime.now().isoformat()}

## Inputs
{self._format_input_manifest(course_id)}

## Applied Rules
{self._format_rules_applied(course_id)}

## Changes Detected
{self._format_changes(course_id)}

## Validation Results
{self._format_validation(course_id)}

## Critical Dates
{self._format_critical_dates(course_id)}

## Contract Compliance
{self._format_contracts(course_id)}

## Generated Artifacts
{self._format_artifacts(course_id)}
"""
        return report
```

## **Phase 7: Production Hardening (Week 7-8)**

### 7.1 Cloudflare Integration

```python
# cloudflare/config.py
HEADERS = {
    'production': {
        '/courses/*/embed/*': {
            'Content-Security-Policy': "frame-ancestors 'self' *.blackboard.com learn-us-east-1-prod-fleet01-xythos.content.blackboardcdn.com",
            'Cache-Control': 'public, max-age=3600',
        }
    },
    'preview': {
        '/courses/*/embed/*': {
            'X-Robots-Tag': 'noindex',
            'Cache-Control': 'no-cache',
        }
    }
}
```

### 7.2 Monitoring and Observability

```python
# scripts/monitoring/health_checks.py
class HealthChecker:
    def check_all(self) -> HealthReport:
        checks = [
            self.check_data_freshness(),
            self.check_build_status(),
            self.check_embed_accessibility(),
            self.check_task_backlog(),
            self.check_schema_versions(),
        ]
        
        return HealthReport(checks, dashboard_url="/health")
```

## **Migration Strategy**

### Week 1: Data Foundation
- Run `add_stable_ids.py` migration
- Add `_meta` blocks to all JSON
- Set up schema versioning

### Week 2-3: Rules Engine
- Implement CourseRulesEngine
- Move all date logic to DateRules
- Test with one course (MATH221)

### Week 4: Service Layer
- Build CourseService
- Implement validation gateway
- Add change detection

### Week 5: Pipeline Integration
- Update builders to use CourseService
- Modify templates to use contexts only
- Dashboard reads intelligence views

### Week 6: Testing
- Set up golden tests
- Implement contract testing
- Generate first build reports

### Week 7-8: Production
- Cloudflare headers and caching
- Monitoring and health checks
- Documentation updates

## **Success Metrics**

1. **Zero template logic** - Templates only format pre-computed values
2. **Single source of truth** - All consumers read from CourseService
3. **Full provenance** - Every generated value traces to its sources
4. **Deterministic builds** - Same inputs always produce same outputs
5. **Change awareness** - System knows exactly what changed and what needs rebuilding

This refactor gives you a solid foundation that will scale to many courses and terms while maintaining clarity and correctness. Each phase builds on the previous one, and you can pause after any phase with a working system.
